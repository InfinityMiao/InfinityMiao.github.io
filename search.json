[{"title":"learned index学习笔记","url":"/2019/10/22/learned index学习笔记/","content":"\n论文链接：https://www.researchgate.net/publication/321512926_The_Case_for_Learned_Index_Structures\n\n## 前言\n\n数据库的索引和机器学习里的预测模型其实有一些相似之处，比如 B 树是把 key 映射到一个有序数组中的某个位置，Hash 索引是把 key 映射到一个无序数组中的某个位置，bitmap 是把 key 映射成是一个布尔值（存在与否）。\n\n所以这就是本文要讨论的地方了，以上的想法是可以实现的。实验表明，在某些数据集上（有规律可循的数据集），用 RM-Index 预测模型代替 B 树之类的数据结构，可以提升 70% 的速度、并节约相当可观的空间。\n\n\n\n## 范围索引\n\nB树和RM-Index有一点很相似，都能够根据输入的数据而确定一个区间，这个区间就包含了最终想要得到的数据。\n\n- B树确定了在区间[pos, pos + pagesize]内\n- RM-Index在预测错误率在 min/max_err 以内时确定了 在[pos - min_err, pos + max_err]内\n\n一图以概之：![img](http://5b0988e595225.cdn.sohucs.com/images/20181105/fe340b92b4954c4880e993211bc35dfd.jpeg)\n\n于是问题变成，如何把预测错误率 bound 在 max_err 以内？那就是训练，在训练集上的error可以降到极低的地步，而所有的数据就是我们的训练集，因此可以不用考虑过拟合的问题，甚至可以将过拟合作为最终的训练目标。而鉴于训练NN（Neural network）的复杂性，RM-Index多用于只读数据库的索引，或者更新较慢的数据库中（例如一天更新一次）。与此同时，NN可以在专用的芯片上获得惊人的速度，例如GPU或者TPU。时间复杂度要比B树的O(logn)快很多。\n\n\n\n## 递归模型索引 RM-Index\n\n以上已经说完了核心思想，接下来就是要找到一个合适的预测模型来代替 B 树。实验发现，直接上 DNN 效果并不好：单次计算代价太大，只能用 GPU（而调用 GPU 会产生不小的 overhead）；而且网络很庞大，retrain（增删改）代价很大。为解决这个问题，决策树给我们做了个很好的提示，如果一个模型解决不了问题，就再加几层。\n\n举个例子：为 100M 记录训练一个足够精确的预测器太难，那就分成 3 层树状结构。根节点分类器把记录分出 100 份，每份大约有 1M 记录；第二层再分出 100 份，每份大约只剩 10K 记录；第三层再分出 100 份，每份大约有 100 条记录——假设 100 条纪录足够把误差在 min/max_err 之内。\n\nRM-Index结构示意：\n\n![img](http://5b0988e595225.cdn.sohucs.com/images/20181105/acca0ca189f643ffaea60a8f2f66b99b.jpeg)\n\n这样做的好处是，每层要做的事情简单多了（每层 precision gain = 100），模型可以变得简单得多。每个 NN 模型就像一个精通自己领域的专家，他只要学习某个很小子集的 keys 就可以了。这也同时解决了 last mile 难题，大不了为这一百左右个 keys 过拟合一下也无妨。\n\n\n\n## 混合索引\n\n然而将数据根据大小分成几堆供不同的NN模型进行训练仍然有可能造成erro_rate过高（也许是因为这一堆的数据毫无规律可循），那么这时候就可以用到传统的预测方法了。\n\n上图中的三层网络结构还带来一个额外的优势：每个 Model 其实是独立的，我们可以用除了 NN 以外的预测方法代替之，包括线性回归等简单算法，甚至是 B 树。\n\n事实上，最后选用了两种 Model：\n\n- 简单的DNN（0～2 层全连接的 hidden layer，ReLU 激发函数，每层最多 32 个神经元）\n- 当叶节点的 NN 模型 error rate 超过阈值时，替换成 B 树\n\n训练算法如下：\n\n![img](http://5b0988e595225.cdn.sohucs.com/images/20181105/71f5f08870a842fd8d48f47c267cf758.jpeg)\n\n1.固定整个 RM-Index 的结构，比如层数、每层 Model 数量等（可以用网格法调参）；\n\n2.用全部数据训练根节点，然后用根节点分类后的数据训练第二层模型，再用第二层分类后的数据训练第三层；\n\n3.对于第三层（叶节点），如果 max_error 大于预设的阈值，就换成 B 树。\n\n\n\n测试结果\n\n为了对比 RM-Index 和 B 树的性能，论文作者找了 4 个数据集，分别用 RM-Index 和 B 树作二级索引。\n\n- Weblogs 数据集：访问时间 timestamp -> log entry （约 200M）\n- Maps 数据集：纬度 longitude -> locations （约 200M）\n- Web-documents 数据集：documents（字符串）-> document-id（约 10M）\n- Lognormal 数据集：按对数正态分布随机生成的数据\n\n测试中用了不同参数的 Learned Index 和 B 树，B 树也用了一个高度优化的实现。\n\n![img](http://5b0988e595225.cdn.sohucs.com/images/20181105/e174ebf808404dd59550d5d92b0fee14.jpeg)\n\n\n\n\n\n## 总结\n\nLearned index适用于规律性强的数据，作这种数据的二级索引再合适不过了。内在规律越强，就意味着 B 树、哈希这些通用算法浪费的越多，这也是ML算法能捡到便宜的地方。\n\n然而缺点也是明显的：增删改代价难以控制，由于神经网络训练的时间以及空间的复杂性，这足以磨平它查找的优势，毕竟大部分的数据库都是要进行频繁的增删改操作的。\n\n但是，不得不肯定的是，作为应用范围最广的B树的地位是难以撼动的，但是在特定场景下（例如只读数据库），learned-index将会是一个现有方法的补充。","tags":["--Learned indrx --机器学习"]},{"title":"Learned Index Structures论文笔记","url":"/2019/10/22/Learned Index Structures论文笔记/","content":"\n论文原地址：","tags":["--Learned indrx --机器学习"]},{"title":"一些JavaScript的坑","url":"/2019/10/20/一些JavaScript的坑/","content":"\n不得不说js是一种有点奇葩的语言，有很多的地方和其他语言不同，在写js的时候如果理所当然的用其他语言的方法去写会有很多的问题。\n\n因此在这里将会有一些JavaScript与其他语言的“与众不同”的地方，避免以后再踩。\n\n## 数组的排序\n\nJavaScript数组默认的排序方式很奇葩，它默认的排序方式array.sort()类似于python中由字符串构成的数组。\n\n```javascript\nlet array = [1,2,13,23,5,7,8,10,11,13,14,16,17,19,20,22];\narray.sort()\nconsole.log(array)\n\n控制台输出：\n[ 1, 10, 11, 13, 13, 14, 16, 17, 19, 2, 20, 22, 23, 5, 7, 8 ]\n```\n\n而如果要对js的数组进行正常的排序，需要自己写判断大小的函数\n\n```javascript\nlet array = [1,2,13,23,5,7,8,10,11,13,14,16,17,19,20,22];\narray.sort(function (m, n) {\n                if (m < n) \n                    return -1\n                else if (m > n) \n                    return 1\n                else \n                    return 0\n            });\nconsole.log(array)\n\n控制台输出：\n[ 1, 2, 5, 7, 8, 10, 11, 13, 13, 14, 16, 17, 19, 20, 22, 23]\n```\n\n","tags":["JavaScript","Nodejs"]},{"title":"JavaScript的遍历方式","url":"/2019/10/18/JavaScript的遍历方式/","content":"\n之前在写用nodejs构建的网站后端时，理所当然的用到了遍历，js的遍历方式有很多种，先记下用到了的遍历方式以及其中遇到的坑。\n\n## 1.for循环\n\nfor循环的用法基本与c/c++类似，除了获得数组长度的方式\n\n```javascript\nvar array = [1,2,3,4,5,6,7,8,9];\nfor(let i = 0;i<array.length;i++){\n    console.log(array[i]);\n}\n```\n\n到目前为止，在使用for循环的代码中没有出现任何bug，因此推荐以后使用最传统的for循环。而其他的几中遍历方式多多少少都会出现问题，估计是nodejs的任务处理逻辑使得对数组对象进行遍历时出现了指针错误？不太清楚，待以后研究。\n\n## 2.for in\n\n for in循环不仅可以遍历数组，还可以遍历对象\n\n```javascript\nvar array = [1,2,3,4,5,6,7,8,9];\nfor(let num in array){\n    console.log(num);\n}\n```\n\n因为之前python写的比较多，所以本来对for in还是很有好感的，因此最开始就是用的for in对数组进行的遍历。但是当我在使用for in遍历一个长度为500的二维数组时，在数组的最后一个位置并没有得到正确的变量，而是一个undefined，即array[499] = undefined，这个bug让我找了很久，也是我遇到的第一个不是我自己造成的坑(＃｀д´)ﾉ，然而令我没想到的是js的遍历还有更多的坑。\n\n## 3.for of\n\nES6中引入了 for ... of 循环，以替代 for...in 和 forEach() ，允许对 Array(数组)、String(字符串)、Maps(映射)、Sets(集合)等可迭代的数据结构进行遍历。\n\n```javascript\nvar array = [1,2,3,4,5,6,7,8,9];\nfor(let num of array){\n    console.log(num);\n}\n```\n\nfor of是我在发现for in的bug之后用来代替的方法，但是我在使用其遍历一个字典的values时出现了问题，当时的代码类似于下面。\n\n```javascript\nvar array = [{1:1,2:2},{1:2,2:3},{1:3,2:4}];\nfor(let dict of Object.values(array)){\n    (function(dict)){\n     \tconsole.log(dict[1],,dict[2]);\n    }(dict)\n}\n```\n\n结果输出结果如下\n\n```\nundefined 2\n2 3\n3 4\n```\n\n又是undefined，真是令人无语，很迷，完全找不到理由，所以我将其改成了for循环。待以后找到原因再说吧，现在对js这种动态语言的好感越来越低了，以后要是再简单的后端的话，我还是用flask吧，js真是一言难尽啊，难怪没什么人用它做后端框架，而是用在前端上。\n\n## 4.for each\n\nforEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。\n```javascript\nvar array = [1,2,3,4,5,6,7,8,9];\narray.forEach(function(num){\n    console.log(num);\n});\n```\n\n目前来说forEach()还没有发现什么别的坑，但是不多不说回调这个东西挺那个的，写的时候还要考虑是不是其他部分的代码对遍历结果是不是立即需要，反正记住回调里的代码会迟于外面的代码运行就行了。\n\n\n\n目前为止，js我只用到过上述的几种遍历方式，感觉js真的有很多的坑，等以后遇到js的其他坑，我再继续记录吧。","tags":["JavaScript","nodejs"]},{"title":"Hello World","url":"/2019/10/18/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"使用 Node.js 打造多用户实时监控系统","url":"/2018/10/21/使用 Node.js 打造多用户实时监控系统/","content":"\n### 背景概述\n\n首先描述一下笔者遇到的问题，我们可以设定这样一个场景：现在有一个实时监控系统的开发需求，要求同时支持多个用户（这里我们为了简化，暂时不涉及登陆态，假定一个设备即为一个用户），对于不同的用户来讲，他们需要监控的一部分内容是完全相同的，比如设备的 CPU 信息、内存信息等，而另外一部分内容是部分用户重叠的，比如对某一区域的用户来说某些监控信息是相同的，而还有一些信息，则是用户之间完全不同的。\n\n对于每个用户来讲，当其进入页面之后即表明其开始监控，需要持续地进行数据更新，而当其退出界面或者手动点击停止监控，则停止监控。\n\n### 问题描述\n\n实际上，对于以上情况，我们很容易想到通过 WebSocket，对不同的用户进行隔离处理，当一个用户开始监控的时候，通过函数来逐个启动其所有的监控项目，当其停止监控的时候，取消相关监控，并且清除无关变量等。我们可以将所有内容写到 WebSocket 的连接回调中，由于作用域隔离，不同用户之间的监控（读操作）不会产生互相影响。\n\n这种方式可以说是最为快捷方便的方式了，并且几乎无需进行设计，但是这样有一个非常明显的效率问题：\n\n由于不同用户的部分监控项目是有重叠的，对于这些重叠的项目，我们如果对于每一个用户都单独监控，那么就会产生非常多的浪费，如果这些监控中还涉及到数据库交互或者较为复杂的计算，那么成倍之后的性能损失是非常难以承受的。\n\n所以，我们需要将不同用户重叠的那些监控项目，进行合并，合并成一个之后，如果有新的消息，我们就推到所有相关用户的回调函数中去处理。\n\n也就是说，我们需要管理一个一对多的订阅发布模式。\n\n到这里，我们发现我们想要实现这样一个监控系统，并不是非常简单，主要有下列问题：\n\n* [1]对于可能有用户重叠的监控项目，我们需要抽离到用户作用域之外，并且通过统计计数等方式来\"记住\"当前所有的监控用户，当有新内容时推到各个用户的处理函数中，并且当最后一个用户取消监控的时候要及时清理相关对象。\n* [2]不同用户的重叠监控项目的监控方式也各不相同，有的是通过 `setInterval` 等方式的定时任务，有的是事件监听器等等。\n* [3]判断不同用户的项目是否重叠也有一定的争议，比如假设不同用户端监控的是同一个项目，调用的也是相同的函数，但是由于用户 ID 不同，这个时候我们如何判断是否算\"同一个监控\"？\n\n以上的这些问题，如果我们不借助现有的库和工具，自己顺着思路一点点去写，则很容易陷入修修补补的循环，无法专注监控本身，并且最后甚至在效率上适得其反。\n\n### 解决方案\n\n以下解决方案基于 Rx.js，需要对 [Observable](https://cn.rx.js.org/class/es6/Observable.js~Observable.html) 有一定了解。\n\n#### 多个用户的监控以及取消\n\n[Monitor-RX](https://github.com/aircloud/monitor-rx) 是对以上场景问题的一个解决方案封装，其利用了 Rx.js 对订阅发布的管理能力，可以让整个流程变的清晰。\n\n在 Rx.js 中，我们可以通过以下方式建立一个多播对象 `multicasted`：\n\n```\nvar source = Rx.from([1, 2, 3]);\nvar subject = new Rx.Subject();\nvar multicasted = source.pipe(multicast(subject)).refCount();\n// 其属于 monitor-rx 的实现细节，无需理解亦可使用 monitor-rx\n\nsubscription1 = refCounted.subscribe({\n    next: (v) => console.log('observerA: ' + JSON.stringify(v))\n});\n\nsetTimeout(() => {\n    subscription2 = refCounted.subscribe({\n        next: (v) => console.log('observerB: ' + JSON.stringify(v))\n    });\n}, 1200);\n\nsubscription1.unsubscribe();\nsetTimeout(() => {\n    subscription2.unsubscribe();\n    // 这里 refCounted 的 unsubscribe 相关清理逻辑会自动被调用\n}, 3200);\n```\n\n在这里采用多播，有如下几个好处：\n\n* 可以随时增加新的订阅者，并且新的订阅者只会收到其加入订阅之后的数据。\n* 可以随时对任意一个订阅者取消订阅。\n* 当所有订阅者取消订阅之后，Observable 会自动触发 Observable 函数，从而可以对其事件循环等进行清理。\n\n以上能力其实可以帮助我们解决上文提到的问题 [1]。\n\n#### 监控格式的统一\n\n实际上，在我们的监控系统中，从数据依赖的角度，我们的监控函数会有这样几类：\n\n* [a]纯粹的定时任务，无数据依赖，这方面比如当前内存快照数据等。\n* [b]带有记忆依赖的定时任务：定时任务依赖前一次的数据（甚至更多次），需要两次数据做差等，这方面的数据比如一段时间的消耗数据，cpu 使用率的计算。\n* [c]带有用户依赖的定时任务：依赖用户 id 等信息，不同用户无法共用。\n\n而从任务触发的角度，我们仍待可以对其分类：\n\n* [i]简单的 `setInterval` 定时任务。\n* [ii]基于事件机制的不定时任务。\n* [iii]基于其他触发机制的任务。\n\n实际上，我们如果采用 Rx.js 的模式进行编写，无需考虑任务的数据依赖和触发的方式，只需写成一个一个 Observable 实例即可。另外，对于比较简单的 [a]&[i] 或 [c]&[i]  类型，我们还可以通过 monitor-rx 提供的 `convertToRx` 或 `convertToSimpleRx` 转换成 Observable 实例生成函数，例如：\n\n```\nvar os = require('os');\nvar process = require('process');\nconst monitorRx = require('monitor-rx');\n\nfunction getMemoryInfo() {\n    return process.memoryUsage();\n}\n\nconst memory = monitorRx.Utils.convertToSimpleRx(getMemoryInfo)\n\n// 或者\n//const memory = monitorRx.Utils.convertToRx({\n//    getMemoryInfo\n//});\n\nmodule.exports = memory;\n```\n\nconvertToRx 相比于 convertToSimpleRx，可以支持函数配置注入（即下文中 opts 的 func 属性和 args 属性）,可以在具体生成 Observable 实例的时候具体指定使用哪些函数以及其参数。\n\n如果是比较复杂的 Observable 类型，那么我们就无法直接通过普通函数进行转化了，这个时候我们遵循 Observable 的标准返回 Observable 生成函数即可（不是直接返回 Observable 实例） \n\n这实际上也对问题 [2] 进行了解决。\n\n#### 监控唯一性：\n\n我们知道，如果两个用户都监控同一个信息，我们可以共用一个 Observable，这里的问题，就是如何定义两个用户的监控是\"相同\"的。\n\n这里我们采用一个可选项 opts 的概念，其一共有如下属性：\n\n```\n{\n    module: 'ModuleName',\n    func: ['FuncName'],\n    args: [['arg1','arg2']],\n    opts: {interval:1000}, \n}\n```\n\nmodule 即用户是对哪一个模块进行监控（实际上是 Observable），func 和 args 则是监控过程中需要调用的函数，我们也可以通过 agrs 传入用户个人信息。于没有内部子函数调用的监控，二者为空即可，opts 是一些其他可选项，比如定义请求间隔等。\n\n之后，我们通过 `JSON.stringify(opts)` 来序列化这个可选项配置，如果两个用户序列化后的可选项配置相同，那么我们就认为这两个用户可以共用一个监控，即共用一个 Observable。\n\n### 更多内容\n\n实际上，借助 Monitor-RX，我们可以很方便的解决上述提出的问题，Monitor-RX 也在积极的更新中，大家可以在[这里](https://github.com/aircloud/monitor-rx)了解到更多的信息。","tags":["javascript","Node.js","Rx.js"]}]